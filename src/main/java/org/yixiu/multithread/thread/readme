线程
    什么是线程
        线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。
    为什么会有线程
        1、在多核CPU中，利用多线程可以实现真正意义上的并行执行。
        2、在一个应用进程中，会存在多个同时执行的任务，如果其中一个任务被阻塞，将会引起不依赖该任务的任务也被阻塞。
           通过对不同任务创建不同的线程去处理，可以提升程序处理的实时性。
        3、线程可以认为是轻量级的进程，所以线程的创建、销毁比进程更快。
    为什么要用多线程
        异步执行
        利用多CPU资源实现真正意义上的并行执行
    线程的应用场景
        使用多线程实现文件下载
        后台任务：如定时向大量(100W以上)的用户发送邮件
        异步处理：记录日志
        多步骤的任务处理，可根据步骤特征选用不同个数和特征的线程来协作处理，多任务的分割，由一个主线程分割给多个线程完成
    多线程的本质是：
        合理的利用多核心CPU资源来实现线程的并行处理，来实现同一个进程内的多个任务的并行执行，同时基于线程本身的异步执行特性，提升任务处理的效率
    Java中使用多线程的方式
        继承Thread类
        实现Runnable接口
        实现Callable接口
    线程的生命周期
        NEW：初始状态，线程被构建，但是还没有调用start方法
        RUNNABLED：运行状态，JAVA线程把操作系统中的就绪和运行两种状态统一称为“运行中”
        BLOCKED：阻塞状态，表示线程进入等待状态,也就是线程因为某种原因放弃了CPU使用权，阻塞也分为几种情况
        WAITING： 等待状态
        TIME_WAITING：超时等待状态，超时以后自动返回
        TERMINATED：终止状态，表示当前线程执行完毕

线程的基本操作
    Thread.join的作用是保证线程执行结果的可见性。
        其底层实现是通过在join方法中调用wait方法，然后再JVM的实现中，当线程退出时调用lock.notify_all(thread)。
        所以Thread.join的本质其实是wait/notifyAll。
    Thread.sleep的作用是使线程暂停执行一段时间，直到等待的时间结束才恢复执行或在这段时间内被中断。
        工作流程：
            挂起线程并修改其运行状态
            用sleep()提供的参数来设置一个定时器。
            当时间结束，定时器会触发，内核收到中断后修改线程的运行状态。
                例如线程会被标志为就绪而进入就绪队列等待调度
        sleep会让出cpu，所以在抢占式的线程调度算法中，当sleep的时间结束之后并不能保证能获得cpu的执行权限。
            思考：
                假设现在是 2019-11-18 12:00:00.000，如果我调用一下Thread.Sleep(1000) ，
                在 2019-11-18 12:00:01.000 的时候，这个线程会不会被唤醒？
                    当使用System.currentTimeMills来计算线程的睡眠时间时会发现计算得到的时间会大于1000，所以要看CPU的调度情况。
                Thread.Sleep(0) 的意义？
                    相当于让出CPU的执行权限----Thread.yield()。操作系统会根据优先级重新分配CPU的资源。
        线程的调度算法
            操作系统中，CPU竞争有很多种策略。Unix系统使用的是时间片算法，而Windows则属于抢占式的。
    wait和notify
        实现：一个线程修改了一个对象的值，而另个线程感知到了变化，然后进行响应的操作

        为什么wait/notify需要加synchronized
            1. wait/notify本质上其实是一种条件的竞争，至少来说，wait和notify方法一定是互斥存在的，synchronized就是一个实现互斥方法
            2. wait和notify是用于实现多个线程之间的通信，而通信必然会存在一个通信的载体，wait/notify是基于synchronized来实现通信的。
               也就是两者必须要在同一个频道也就是同一个锁的范围内。
            或者从底层来看，wait和notify操作的是互斥锁的等待队列，所以要先获取互斥锁，才可以进行操作。
    Thread.interrupted
        对设置中断标识的线程复位，并且返回当前的中断状态。
    Thread.interrupt
        当其他线程通过调用当前线程的interrupt方法，表示向当前线程打个招呼，告诉他可以中断线程的执行了，至于什么时候中断，取决于当前线程自己。
        什么时候调用interrupt方法：
            //while  一般需要一个中断标志，可以使用if(Thread.currentThread().isInterrupted())作为标志
            //线程处于阻塞状态下的情况下(中断才有意义） 下面几个方法都会抛出InterruptedException异常
                //thread.join
                //wait
                //Thread.sleep
        什么情况下会抛出InterruptedException：
            处于阻塞状态下的操作被interrupt方法中断。
