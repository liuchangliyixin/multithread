注解
    定义：
        注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。
        它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。

        注解：说明程序的。给计算机看的
        注释：用文字描述程序的。给程序员看的

    作用分类：1和3是预置功能，2是需要进行分析的
    	1.编写文档：通过代码里标识的注解生成文档【生成文档doc文档】
    	    /**
             *  注解JavaDoc描述
             *
             * @author yixiu
             * @version 1.0
             * @since jdk1.5
             */
            public class User {

                private Integer id;

                private String userName;

                @Override
                public String toString() {
                    return "User{" +
                            "id=" + id +
                            ", userName='" + userName + '\'' +
                            '}';
                }

                /**
                 * 两数相加
                 * @param a  第一个整数
                 * @param b  第二个整数
                 * @return  返回结果
                 */
                public int add(int a,int b){
                    return a + b;
                }
            }

            通过命令行调用：javadoc User.java 即可生成对应的Java文档
    	2.代码分析：通过代码里标识的注解对代码进行分析【使用反射】
    	3.编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】

    JDK中预定义的注解
    	@Override：检测被该注解标注的方法是否是继承自父类(接口)的
    	@Deprecated：该注解标注的内容，表示已过时
    	@SuppressWarnings：压制警告
    		一般传递参数all  @SuppressWarnings("all")
    		一般加在类的头部，这样类中所有的警告标志(一般为黄色的线)就都没了

    自定义注解
    	格式：
    		元注解
    		public @interface 注解名称{
    			属性列表;
    		}

    	本质：注解本质上就是一个接口，该接口默认继承Annotation接口
            public interface MyAnno extends java.lang.annotation.Annotation {}
            实现步骤：
                定义一个注解：
                    public @interface MyAnno {}
                编译：javac MyAnno.java
                反编译：javap MyAnno.class
                就可以得到：public interface MyAnno extends java.lang.annotation.Annotation {}

    	属性：接口中的抽象方法
    		要求：
    			1. 属性的返回值类型有下列取值
    				基本数据类型
    				String
    				枚举
    				注解
    				以上类型的数组

    			2. 定义了属性，在使用时需要给属性赋值

            1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。
                int age() default 18;
            2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。
                String value();
            3. 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略

        元注解：用于描述注解的注解
            @Target：描述注解能够作用的位置
                ElementType取值：
                    TYPE：可以作用于类上
                    METHOD：可以作用于方法上
                    FIELD：可以作用于成员变量上

            @Retention：描述注解被保留的阶段
                SOURCE < CLASS < RUNTIME
                    SOURCE:表示当前注解只在代码阶段有效
                    CLASS:表示该注解会被保留到字节码阶段
                    RUNTIME:表示该注解会被保留到运行阶段 JVM

                    自定义的注解：RetentionPolicy.RUNTIME
                    @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到

            @Documented：描述注解是否被抽取到api文档中
                注解加上注解@Documented，会在api文档中显示出来
            @Inherited：描述注解是否被子类继承
                注解加上注解@Inherited，带有注解的当前类的子类也会继承当前注解

        自定义注解案例实现
            /**
             * 自定义注解
             *     该注解表面要执行哪个类中的哪个方法
             */
            @Target(ElementType.TYPE)
            @Retention(RetentionPolicy.RUNTIME)
            public @interface InvokAnno {

                String className();
                String methodName();
            }



            public class Student1 {
                public void show(){
                    System.out.println("student1 show ....");
                }
            }

            @InvokAnno(className = "com.yixiu.anno2.Student2",methodName = "show")
            public class MyMain {

                public static void main(String[] args) throws Exception {
                    // 获取类对象
                    Class<MyMain> clazz = MyMain.class;
                    // 获取类对象中的注解
                    InvokAnno an = clazz.getAnnotation(InvokAnno.class);
                    /**
                     *  注解本质是 接口  获取到的其实是接口的实现
                     *  public class MyInvokAnno implements InvokAnno{
                     *
                     *      String className(){
                     *          return "com.yixiu.anno2.Student1";
                     *      }
                     *      String methodName(){
                     *          return "show";
                     *      }
                     *  }
                     */
                    // 获取注解中对应的属性
                    String className = an.className();
                    String methodName = an.methodName();
                    System.out.println(className);
                    System.out.println(methodName);

                    // 通过反射的方式实现接口的功能
                    Class<?> aClass = Class.forName(className);
                    Method show = aClass.getDeclaredMethod("show");
                    // 方法的执行
                    Object o = aClass.newInstance();
                    show.invoke(o); // 执行对应的方法
                }
            }
